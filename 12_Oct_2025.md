Beautiful foundation, Harsh ğŸŒ¸
Your **Day 1 log** already shows focused, deep learning â€” we just need to polish the formatting, fix small markdown issues, and make it visually consistent and easy to scan later when you revise.

Hereâ€™s your **refined and professional version** (ready to paste in your repo):

---

# ğŸ§˜â€â™‚ï¸ Daily Log

## **Day 1 â€” October 12, 2025**

---

### ğŸ§© **Tasks Completed**

* Revisited **Conditional Statements**
* Revised **previous concepts**

---

### ğŸ§  **DSA Practice**

---

#### **Q1. Contains Duplicate**

ğŸ”— [LeetCode Problem Link](https://leetcode.com/problems/contains-duplicate/description/)

**ğŸ¯ Goal:**
Check if an array has any duplicate elements.

---

#### **Approaches**

| Approach       | Idea                                            | Time       | Space | Remarks  |
| -------------- | ----------------------------------------------- | ---------- | ----- | -------- |
| Brute Force    | Compare each element with all others            | O(nÂ²)      | O(1)  | Too slow |
| Sort + Compare | Sort the array, then check consecutive elements | O(n log n) | O(1)  | Better   |
| HashSet (Best) | Use a Set to track seen numbers                 | O(n)       | O(n)  | Fastest  |

---

#### **Java Code (HashSet Approach)**

```java
import java.util.HashSet;

class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> seen = new HashSet<>();
        for (int num : nums) {
            if (seen.contains(num)) {
                return true; // Duplicate found
            }
            seen.add(num);
        }
        return false; // No duplicates
    }
}
```

---

#### **Java Code (Sort + Compare Approach)**

```java
import java.util.Arrays;

class Solution {
    public boolean containsDuplicate(int[] nums) {
        Arrays.sort(nums);
        for (int i = 0; i < nums.length - 1; i++) {
            if (nums[i] == nums[i + 1]) {
                return true; // Adjacent elements are same
            }
        }
        return false;
    }
}
```

---

#### âš™ï¸ **Key Takeaways: O(n) vs O(n log n)**

* **O(n):** One pass through all elements â†’ linear growth.
* **O(n log n):** Sorting required â†’ slightly slower.
* For large arrays, always prefer **O(n)** if possible.
* Sorting is only needed when **order matters** or no faster solution exists.

---

#### ğŸ§© **Concept Summary**

* **O(n)** â†’ One direct loop
* **O(n log n)** â†’ Sorting-based
* **Set** is ideal for quick membership checks (constant time)

---

#### **Visual Flow (HashSet Approach)**

```
Input: [1, 2, 3, 2]
â†“
Loop through array:
1 â†’ add to Set
2 â†’ add to Set
3 â†’ add to Set
2 â†’ already exists â†’ return true
```

---

#### **Q2. Richest Customer Wealth**

ğŸ”— [LeetCode Problem Link](https://leetcode.com/problems/richest-customer-wealth/description/)

**ğŸ¯ Goal:**
Find the maximum sum of account balances for any customer.

---

#### **Input Format**

* 2D Array `accounts[i][j]` â†’

  * `i` â†’ Customer index (row)
  * `j` â†’ Bank account index (column)

---

#### **Steps**

1. Initialize `maxWealth = 0`
2. For each customer:

   * Reset `currentCustomerWealth = 0`
   * Add all their bank balances
   * Update `maxWealth` if higher
3. Return `maxWealth`

---

#### **Java Code (Refined and Commented)**

```java
class Solution {
    public int maximumWealth(int[][] accounts) {
        int maxWealth = 0; // stores richest customer's total wealth

        // Outer loop â†’ each customer
        for (int customer = 0; customer < accounts.length; customer++) {
            int currentCustomerWealth = 0; // reset for each customer

            // Inner loop â†’ each bank account for that customer
            for (int bank = 0; bank < accounts[customer].length; bank++) {
                currentCustomerWealth += accounts[customer][bank];
            }

            // Update maxWealth if current customer is richer
            if (currentCustomerWealth > maxWealth) {
                maxWealth = currentCustomerWealth;
            }
        }

        return maxWealth; // final richest wealth
    }
}
```

---

#### **Concepts & Visualization**

```
accounts = [
 [1, 5],   â†’ wealth = 6
 [7, 3],   â†’ wealth = 10
 [3, 5]    â†’ wealth = 8
]

maxWealth = 10 (richest customer)
```

**Key Pattern:**

* Outer loop â†’ Customers
* Inner loop â†’ Accounts
* Reset `currentCustomerWealth` each time
* Keep updating `maxWealth`

**Complexity:**

* â± **Time:** O(n Ã— m) â†’ n customers, m accounts each
* ğŸ’¾ **Space:** O(1)

---

### ğŸŒ± **Todayâ€™s Key Learnings**

#### 1ï¸âƒ£ **Depth over Quantity**

* Solving **2 questions deeply** gave more learning than solving 20 shallowly.
* True growth = understanding *why* and *how*, not just *what*.

#### 2ï¸âƒ£ **Retention through Understanding**

* Once logic is clear, memory becomes natural.
* Concepts like nested loops and `i/j` indexing now feel intuitive.

#### 3ï¸âƒ£ **Visualization & Notes**

* Drawing small diagrams helps you **see** logic flow.
* Writing short notes in your own words reinforces memory.

#### 4ï¸âƒ£ **Sahaj Learning Principle**

* Focused, calm learning is most effective.
* Like meditation, quality matters more than quantity.
* The joy of understanding is itself the learning.

---

Would you like me to make a **Day 1 header banner** (with emojis, date, and topic icons) that you can add to all daily logs so they visually look uniform across the repo?
Itâ€™ll make your logs look like a â€œDaily Code Journal.â€
