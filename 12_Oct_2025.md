
## Day 1 - October 12, 2025

### **Tasks Completed**

* Revisited Conditional Statements
* Revised previous concepts

---

### **DSA Practice**

#### **Q1: Contains Duplicate**

[LeetCode Problem Link](https://leetcode.com/problems/contains-duplicate/description/)

**Goal:** Check if an array has any duplicate elements.

**Approaches:**

1. **Brute Force:** Compare each element with all others → O(n²) → slow.
2. **Sort + Compare:** Sort array → check consecutive elements → O(n log n).
3. **HashSet (best):** Loop once → check if element is in Set → O(n) time, O(n) space.

**Steps (HashSet approach):**

* Create an empty HashSet.
* Loop through array:

  * If element is already in Set → return true.
  * Else, add element to Set.
* If loop ends → return false.

**Java Code (HashSet approach):**

```java
import java.util.HashSet;

class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> seen = new HashSet<>();
        for (int num : nums) {
            if (seen.contains(num)) {
                return true; // duplicate found
            }
            seen.add(num);
        }
        return false; // no duplicates
    }
}
```

**Java Code (Sort + Compare approach):**

```java
import java.util.Arrays;

class Solution {
    public boolean containsDuplicate(int[] nums) {
        Arrays.sort(nums);
        for (int i = 0; i < nums.length - 1; i++) {
            if (nums[i] == nums[i + 1]) {
                return true;
            }
        }
        return false;
    }
}
```

**Key Takeaways: O(n) vs O(n log n)**

* **O(n):** One pass through all elements → linear growth
* **O(n log n):** Requires sorting → grows slightly faster than linear
* For large arrays, O(n) is faster and preferred when possible

---

#### **Q2: Richest Customer Wealth**

[LeetCode Problem Link]
(https://leetcode.com/problems/richest-customer-wealth/description/)

**Goal:** Find the maximum sum of account balances for any customer.

**Input:** 2D array `accounts[i][j]` → i-th customer, j-th bank.

**Steps:**

1. Initialize `maxWealth = 0`.
2. Loop through each customer (outer loop, `i`):

   * Initialize `currentCustomerWealth = 0`.
   * Loop through each account of that customer (inner loop, `j`):

     * Add to `currentCustomerWealth`.
   * Compare with `maxWealth` → update if greater.
3. Return `maxWealth`.

**Java Code:**

class Solution {
    public int maximumWealth(int[][] accounts) {
        int maxWealth = 0; // maximum wealth across all customers

        // Loop through each customer
        for (int i = 0; i < accounts.length; i++) {
            int currentCustomerWealth = 0; // sum for current customer

            // Loop through each bank account of the current customer
            for (int j = 0; j < accounts[i].length; j++) {
                currentCustomerWealth += accounts[i][j];
            }

            // Update maxWealth if current customer's wealth is greater
            if (currentCustomerWealth > maxWealth) {
                maxWealth = currentCustomerWealth;
            }
        }

        return maxWealth; // return the highest wealth
    }
}
```

**Extra Explanation:**

* `i` → index of customers (rows)
* `j` → index of bank accounts for i-th customer (columns)
* `currentCustomerWealth` → sum for current customer (reset each row)
* `maxWealth` → stores highest wealth found so far

**Pattern:**

* Outer loop → each customer
* Inner loop → each bank account
* Sum variables inside outer loop, max variables outside

---

### **Today’s Key Learnings**

1. **Depth over Quantity**

   * 2 deep problems give more learning than 100 shallow ones.
   * Tracing logic, visualizing loops, and reasoning deeply is more effective.

2. **Retention Through Understanding**

   * Fully understanding loops and sums creates mental models.
   * Concepts like `i` and `j` in 2D arrays apply to hundreds of problems.

3. **Visualization & Notes**

   * Draw diagrams for clarity
   * Write small notes in your own words
   * Mentally trace examples

4. **Sahaj Learning Principle**

   * Short, focused, deep sessions are more effective than long, shallow ones.
   * Focus on understanding, not just solving numbers of questions.